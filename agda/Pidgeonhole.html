<!DOCTYPE HTML>
<html><head><meta charset="utf-8"><title>Pidgeonhole</title><link rel="stylesheet" href="Agda.css"></head><body><pre class="Agda"><a id="1" class="Keyword">module</a> <a id="8" href="Pidgeonhole.html" class="Module">Pidgeonhole</a> <a id="20" class="Keyword">where</a>

<a id="27" class="Keyword">open</a> <a id="32" class="Keyword">import</a> <a id="39" href="Basic.html" class="Module">Basic</a> <a id="45" class="Keyword">hiding</a> <a id="52" class="Symbol">(</a><a id="53" href="Agda.Builtin.Sigma.html#166" class="Record">Σ</a><a id="54" class="Symbol">)</a>
<a id="56" class="Keyword">open</a> <a id="61" class="Keyword">import</a> <a id="68" href="Util.Arithmetic.html" class="Module">Util.Arithmetic</a>
<a id="84" class="Keyword">open</a> <a id="89" class="Keyword">import</a> <a id="96" href="Util.Vec.html" class="Module">Util.Vec</a> <a id="105" class="Keyword">renaming</a> <a id="114" class="Symbol">(</a><a id="115" href="Util.Vec.html#1875" class="Function">Vec-sum</a> <a id="123" class="Symbol">to</a> <a id="Vec.Vec-sum"></a><a id="126" href="Pidgeonhole.html#126" class="Function">Σ</a> <a id="128" class="Symbol">;</a> <a id="130" href="Util.Vec.html#1293" class="Function">Vec-any</a> <a id="138" class="Symbol">to</a> <a id="Vec.Vec-any"></a><a id="141" href="Pidgeonhole.html#141" class="Function">∃</a> <a id="143" class="Symbol">;</a> <a id="145" href="Util.Vec.html#1537" class="Function">Vec-any-monotonic</a> <a id="163" class="Symbol">to</a> <a id="Vec.Vec-any-monotonic"></a><a id="166" href="Pidgeonhole.html#166" class="Function">∃-monotonic</a><a id="177" class="Symbol">)</a>


<a id="181" class="Comment">{-
The pidgeonhole principle.

If n &gt; m, and you put n objects in m boxes, then some box will contain more than 1 object.

Here restated in terms of arithmetic:

If n &gt; m, and you have a vector v, where |v|=m and Σv=n, then for some i &lt; m, v[i]&gt;1.

There are no cases when m or n = 0.

If m, n ≠ 0 then this will return the first index i such that v[i] &gt; 1


-}</a>
<a id="543" class="Comment">-- would be nice if builtin Nats let you pattern-match on (1+n) for (suc n), (2+n) for (suc (suc n)) etc...</a>
<a id="pidgeonhole"></a><a id="651" href="Pidgeonhole.html#651" class="Function">pidgeonhole</a> <a id="663" class="Symbol">:</a> <a id="665" class="Symbol">(</a><a id="666" href="Pidgeonhole.html#666" class="Bound">m</a> <a id="668" href="Pidgeonhole.html#668" class="Bound">n</a> <a id="670" class="Symbol">:</a> <a id="672" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="673" class="Symbol">)</a> <a id="675" class="Symbol">→</a> <a id="677" href="Pidgeonhole.html#666" class="Bound">m</a> <a id="679" href="Data.Nat.Base.html#1645" class="Function Operator">&lt;</a> <a id="681" href="Pidgeonhole.html#668" class="Bound">n</a> <a id="683" class="Symbol">→</a> <a id="685" class="Symbol">(</a><a id="686" href="Pidgeonhole.html#686" class="Bound">v</a> <a id="688" class="Symbol">:</a> <a id="690" href="Data.Vec.Base.html#998" class="Datatype">Vec</a> <a id="694" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a> <a id="696" href="Pidgeonhole.html#666" class="Bound">m</a><a id="697" class="Symbol">)</a> <a id="699" class="Symbol">→</a> <a id="701" href="Pidgeonhole.html#668" class="Bound">n</a> <a id="703" href="Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="705" class="Symbol">(</a><a id="706" href="Pidgeonhole.html#126" class="Function">Σ</a> <a id="708" href="Pidgeonhole.html#686" class="Bound">v</a><a id="709" class="Symbol">)</a> <a id="711" class="Symbol">→</a> <a id="713" href="Pidgeonhole.html#141" class="Function">∃</a> <a id="715" href="Pidgeonhole.html#686" class="Bound">v</a> <a id="717" class="Symbol">(λ</a> <a id="720" href="Pidgeonhole.html#720" class="Bound">x</a> <a id="722" class="Symbol">→</a> <a id="724" href="Pidgeonhole.html#720" class="Bound">x</a> <a id="726" href="Data.Nat.Base.html#1709" class="Function Operator">&gt;</a> <a id="728" class="Number">1</a><a id="729" class="Symbol">)</a>
<a id="731" href="Pidgeonhole.html#651" class="Function">pidgeonhole</a> <a id="743" href="Pidgeonhole.html#743" class="Bound">m</a> <a id="745" class="Number">0</a> <a id="747" class="Symbol">()</a>
<a id="750" href="Pidgeonhole.html#651" class="Function">pidgeonhole</a> <a id="762" class="Number">0</a> <a id="764" class="Symbol">(</a><a id="765" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="769" href="Pidgeonhole.html#769" class="Bound">n</a><a id="770" class="Symbol">)</a> <a id="772" class="Symbol">_</a> <a id="774" href="Data.Vec.Base.html#1034" class="InductiveConstructor">[]</a> <a id="777" class="Symbol">()</a>
<a id="780" href="Pidgeonhole.html#651" class="Function">pidgeonhole</a> <a id="792" class="Number">1</a> <a id="794" class="Symbol">(</a><a id="795" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="799" href="Pidgeonhole.html#799" class="Bound">n</a><a id="800" class="Symbol">)</a> <a id="802" href="Pidgeonhole.html#802" class="Bound">1&lt;sn</a> <a id="807" class="Symbol">(</a><a id="808" href="Pidgeonhole.html#808" class="Bound">x</a> <a id="810" href="Data.Vec.Base.html#1053" class="InductiveConstructor Operator">∷</a> <a id="812" href="Data.Vec.Base.html#1034" class="InductiveConstructor">[]</a><a id="814" class="Symbol">)</a> <a id="816" href="Pidgeonhole.html#816" class="Bound">sn=x</a> <a id="821" class="Symbol">=</a> <a id="823" href="Data.Fin.Base.html#1148" class="InductiveConstructor">zero</a> <a id="828" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="830" href="Pidgeonhole.html#846" class="Function">x&gt;1</a>
  <a id="836" class="Keyword">where</a>
    <a id="846" href="Pidgeonhole.html#846" class="Function">x&gt;1</a> <a id="850" class="Symbol">=</a> <a id="852" href="Relation.Binary.PropositionalEquality.Core.html#1932" class="Function">resp</a> <a id="857" class="Symbol">(λ</a> <a id="860" href="Pidgeonhole.html#860" class="Bound">x</a> <a id="862" class="Symbol">→</a> <a id="864" href="Pidgeonhole.html#860" class="Bound">x</a> <a id="866" href="Data.Nat.Base.html#1709" class="Function Operator">&gt;</a> <a id="868" class="Number">1</a><a id="869" class="Symbol">)</a> <a id="871" class="Symbol">(</a><a id="872" href="Relation.Binary.PropositionalEquality.Core.html#1729" class="Function">≡-trans</a> <a id="880" href="Pidgeonhole.html#816" class="Bound">sn=x</a> <a id="885" class="Symbol">(</a><a id="886" href="Data.Nat.Properties.html#13218" class="Function">+-identityʳ</a> <a id="898" href="Pidgeonhole.html#808" class="Bound">x</a><a id="899" class="Symbol">))</a> <a id="902" href="Pidgeonhole.html#802" class="Bound">1&lt;sn</a>
    
<a id="912" href="Pidgeonhole.html#651" class="Function">pidgeonhole</a> <a id="924" class="Symbol">(</a><a id="925" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="929" class="Symbol">(</a><a id="930" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="934" href="Pidgeonhole.html#934" class="Bound">m</a><a id="935" class="Symbol">))</a> <a id="938" class="Symbol">(</a><a id="939" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="943" href="Pidgeonhole.html#943" class="Bound">n</a><a id="944" class="Symbol">)</a> <a id="946" href="Pidgeonhole.html#946" class="Bound">sn&gt;ssm</a> <a id="953" class="Symbol">(</a><a id="954" class="Number">0</a> <a id="956" href="Data.Vec.Base.html#1053" class="InductiveConstructor Operator">∷</a> <a id="958" href="Pidgeonhole.html#958" class="Bound">xs</a><a id="960" class="Symbol">)</a> <a id="962" href="Pidgeonhole.html#962" class="Bound">sn=Σxs</a> <a id="969" class="Symbol">=</a> <a id="971" href="Pidgeonhole.html#166" class="Function">∃-monotonic</a> <a id="983" class="Symbol">(λ</a> <a id="986" href="Pidgeonhole.html#986" class="Bound">x</a> <a id="988" class="Symbol">→</a> <a id="990" href="Pidgeonhole.html#986" class="Bound">x</a> <a id="992" href="Data.Nat.Base.html#1709" class="Function Operator">&gt;</a> <a id="994" class="Number">1</a><a id="995" class="Symbol">)</a> <a id="997" class="Symbol">(</a><a id="998" href="Pidgeonhole.html#651" class="Function">pidgeonhole</a> <a id="1010" class="Symbol">(</a><a id="1011" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="1015" href="Pidgeonhole.html#934" class="Bound">m</a><a id="1016" class="Symbol">)</a> <a id="1018" class="Symbol">(</a><a id="1019" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="1023" href="Pidgeonhole.html#943" class="Bound">n</a><a id="1024" class="Symbol">)</a> <a id="1026" href="Pidgeonhole.html#1057" class="Function">sn&gt;sm</a> <a id="1032" href="Pidgeonhole.html#958" class="Bound">xs</a> <a id="1035" href="Pidgeonhole.html#962" class="Bound">sn=Σxs</a><a id="1041" class="Symbol">)</a> <a id="1043" class="Number">0</a>
  <a id="1047" class="Keyword">where</a>
    <a id="1057" href="Pidgeonhole.html#1057" class="Function">sn&gt;sm</a> <a id="1063" class="Symbol">=</a> <a id="1065" href="Util.Arithmetic.html#2298" class="Function">x&gt;sy→x&gt;y</a> <a id="1074" href="Pidgeonhole.html#946" class="Bound">sn&gt;ssm</a>
    
<a id="1086" href="Pidgeonhole.html#651" class="Function">pidgeonhole</a> <a id="1098" class="Symbol">(</a><a id="1099" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="1103" class="Symbol">(</a><a id="1104" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="1108" href="Pidgeonhole.html#1108" class="Bound">m</a><a id="1109" class="Symbol">))</a> <a id="1112" class="Symbol">(</a><a id="1113" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="1117" href="Pidgeonhole.html#1117" class="Bound">n</a><a id="1118" class="Symbol">)</a> <a id="1120" href="Pidgeonhole.html#1120" class="Bound">sn&gt;ssm</a> <a id="1127" class="Symbol">(</a><a id="1128" class="Number">1</a> <a id="1130" href="Data.Vec.Base.html#1053" class="InductiveConstructor Operator">∷</a> <a id="1132" href="Pidgeonhole.html#1132" class="Bound">xs</a><a id="1134" class="Symbol">)</a> <a id="1136" href="Pidgeonhole.html#1136" class="Bound">sn=Σv</a> <a id="1142" class="Symbol">=</a> <a id="1144" href="Pidgeonhole.html#1264" class="Function">proof</a>
  <a id="1152" class="Keyword">where</a>
    <a id="1162" href="Pidgeonhole.html#1162" class="Function">n=Σxs</a> <a id="1168" class="Symbol">:</a> <a id="1170" href="Pidgeonhole.html#1117" class="Bound">n</a> <a id="1172" href="Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="1174" href="Pidgeonhole.html#126" class="Function">Σ</a> <a id="1176" href="Pidgeonhole.html#1132" class="Bound">xs</a>
    <a id="1183" href="Pidgeonhole.html#1162" class="Function">n=Σxs</a> <a id="1189" class="Symbol">=</a> <a id="1191" href="Relation.Binary.PropositionalEquality.Core.html#1130" class="Function">cong</a> <a id="1196" href="Data.Nat.Base.html#2880" class="Function">pred</a> <a id="1201" href="Pidgeonhole.html#1136" class="Bound">sn=Σv</a>

    <a id="1212" href="Pidgeonhole.html#1212" class="Function">n&gt;sm</a> <a id="1217" class="Symbol">:</a> <a id="1219" href="Pidgeonhole.html#1117" class="Bound">n</a> <a id="1221" href="Data.Nat.Base.html#1709" class="Function Operator">&gt;</a> <a id="1223" class="Symbol">(</a><a id="1224" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="1228" href="Pidgeonhole.html#1108" class="Bound">m</a><a id="1229" class="Symbol">)</a>
    <a id="1235" href="Pidgeonhole.html#1212" class="Function">n&gt;sm</a> <a id="1240" class="Symbol">=</a> <a id="1242" href="Util.Arithmetic.html#2424" class="Function">sx&gt;sy→x&gt;y</a> <a id="1252" href="Pidgeonhole.html#1120" class="Bound">sn&gt;ssm</a>

    <a id="1264" href="Pidgeonhole.html#1264" class="Function">proof</a> <a id="1270" class="Symbol">=</a> <a id="1272" href="Pidgeonhole.html#166" class="Function">∃-monotonic</a> <a id="1284" class="Symbol">(λ</a> <a id="1287" href="Pidgeonhole.html#1287" class="Bound">x</a> <a id="1289" class="Symbol">→</a> <a id="1291" href="Pidgeonhole.html#1287" class="Bound">x</a> <a id="1293" href="Data.Nat.Base.html#1709" class="Function Operator">&gt;</a> <a id="1295" class="Number">1</a><a id="1296" class="Symbol">)</a> <a id="1298" class="Symbol">(</a><a id="1299" href="Pidgeonhole.html#651" class="Function">pidgeonhole</a> <a id="1311" class="Symbol">(</a><a id="1312" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="1316" href="Pidgeonhole.html#1108" class="Bound">m</a><a id="1317" class="Symbol">)</a> <a id="1319" href="Pidgeonhole.html#1117" class="Bound">n</a> <a id="1321" href="Pidgeonhole.html#1212" class="Function">n&gt;sm</a> <a id="1326" href="Pidgeonhole.html#1132" class="Bound">xs</a> <a id="1329" href="Pidgeonhole.html#1162" class="Function">n=Σxs</a><a id="1334" class="Symbol">)</a> <a id="1336" class="Number">1</a>

<a id="1339" href="Pidgeonhole.html#651" class="Function">pidgeonhole</a> <a id="1351" class="Symbol">(</a><a id="1352" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="1356" class="Symbol">(</a><a id="1357" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="1361" href="Pidgeonhole.html#1361" class="Bound">m</a><a id="1362" class="Symbol">))</a> <a id="1365" class="Symbol">(</a><a id="1366" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="1370" href="Pidgeonhole.html#1370" class="Bound">n</a><a id="1371" class="Symbol">)</a> <a id="1373" class="Symbol">_</a> <a id="1375" class="Symbol">((</a><a id="1377" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="1381" class="Symbol">(</a><a id="1382" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="1386" href="Pidgeonhole.html#1386" class="Bound">k</a><a id="1387" class="Symbol">))</a> <a id="1390" href="Data.Vec.Base.html#1053" class="InductiveConstructor Operator">∷</a> <a id="1392" href="Pidgeonhole.html#1392" class="Bound">xs</a><a id="1394" class="Symbol">)</a> <a id="1396" class="Symbol">_</a> <a id="1398" class="Symbol">=</a> <a id="1400" href="Data.Fin.Base.html#1148" class="InductiveConstructor">zero</a> <a id="1405" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="1407" class="Symbol">(</a><a id="1408" href="Data.Nat.Base.html#1600" class="InductiveConstructor">s≤s</a> <a id="1412" class="Symbol">(</a><a id="1413" href="Data.Nat.Base.html#1600" class="InductiveConstructor">s≤s</a> <a id="1417" href="Data.Nat.Base.html#1558" class="InductiveConstructor">z≤n</a><a id="1420" class="Symbol">))</a>
</pre></body></html>